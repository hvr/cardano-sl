{-# LANGUAGE TypeFamilies #-}

{-# OPTIONS_GHC -fno-warn-orphans #-}

-- | Core types from SSC.

module Pos.Core.Ssc.Types
       (
         -- * Misc
         NodeSet

       -- * Commitments
       , Commitment (..)
       , CommitmentSignature
       , SignedCommitment
       , CommitmentsMap (getCommitmentsMap)
       , mkCommitmentsMap
       , mkCommitmentsMapUnsafe

       -- * Openings
       , Opening (..)
       , OpeningsMap

       -- * Shares
       , InnerSharesMap
       , SharesMap
       , SharesDistribution

         -- * Vss certificates
       , VssCertificate (..)
       , _vcVssKey
       , _vcExpiryEpoch
       , _vcSignature
       , _vcSigningKey
       , getCertId
       , toCertPair
       , VssCertificatesMap (..)
       , mkVssCertificatesMap
       , mkVssCertificatesMapLossy

       -- * Payload and proof
       , VssCertificatesHash
       , SscPayload (..)
       , SscProof (..)
       ) where

import           Universum

import           Control.Lens (makeLensesFor, makeWrapped)
import           Data.Hashable (Hashable (..))
import qualified Data.HashMap.Strict as HM
import qualified Data.HashSet as HS
import           Data.List.Extra (nubOrdOn)
import qualified Data.Text.Buildable as Buildable
import           Data.Text.Lazy.Builder (Builder)
import           Fmt (genericF)
import           Formatting (Format, bprint, build, int, (%))
import           Serokell.Util (allDistinct, listJson)

import           Pos.Binary.Class (AsBinary (..), Bi (..), Decoder, Encoding,
                                   Field (..), Cons (..), cborError,
                                   deriveSimpleBi, enforceSize, encodeListLen,
                                   serialize')
import           Pos.Core.Common (StakeholderId, addressHash)
import           Pos.Core.Slotting.Types (EpochIndex)
import           Pos.Crypto (DecShare, EncShare, Hash, PublicKey, Secret, SecretProof, Signature,
                             VssPublicKey, shortHashF)

type NodeSet = HashSet StakeholderId

----------------------------------------------------------------------------
-- Commitments
----------------------------------------------------------------------------

-- | Commitment is a message generated during the first stage of SSC.
-- It contains encrypted shares and proof of secret.
--
-- There can be more than one share generated for a single participant.
data Commitment = Commitment
    { commProof  :: !SecretProof
    , commShares :: !(HashMap (AsBinary VssPublicKey)
                              (NonEmpty (AsBinary EncShare)))
    } deriving (Show, Eq, Generic)

instance NFData Commitment
instance Hashable Commitment

instance Ord Commitment where
    compare = comparing (serialize' . commProof) <>
              comparing (sort . HM.toList . commShares)

instance Bi Commitment where
    encode Commitment{..} = encodeListLen 2 <> encode commShares
                                            <> encode commProof
    decode = do
        enforceSize "Commitment" 2
        commShares <- decode
        when (null commShares) $ cborError "decode@Commitment: no shares"
        commProof <- decode
        return $ Commitment commProof commShares

-- | Signature which ensures that commitment was generated by node
-- with given public key for given epoch.
type CommitmentSignature = Signature (EpochIndex, Commitment)

type SignedCommitment = (PublicKey, Commitment, CommitmentSignature)

-- | 'CommitmentsMap' is a wrapper for 'HashMap StakeholderId SignedCommitment'
-- which ensures that keys are consistent with values, i. e. 'PublicKey'
-- from 'SignedCommitment' corresponds to key which is 'StakeholderId'.
newtype CommitmentsMap = CommitmentsMap
    { getCommitmentsMap :: HashMap StakeholderId SignedCommitment
    } deriving (Generic, Semigroup, Monoid, Show, Eq, ToList, NFData)

instance Bi CommitmentsMap where
    encode = encodeCommitments
    decode = decodeCommitments

encodeCommitments :: CommitmentsMap -> Encoding
encodeCommitments = encode . HS.fromList . toList

decodeCommitments :: Decoder s CommitmentsMap
decodeCommitments = do
    comms <- toList <$> decode @(HashSet SignedCommitment)
    unless (allDistinct (map (view _1) comms :: [PublicKey])) $ cborError $
        "decodeCommitments: two commitments have the same signing key"
    pure (mkCommitmentsMap comms)

type instance Element CommitmentsMap = SignedCommitment

-- | Safe constructor of 'CommitmentsMap'.
mkCommitmentsMap :: [SignedCommitment] -> CommitmentsMap
mkCommitmentsMap = CommitmentsMap . HM.fromList . map toCommPair
  where
    toCommPair signedComm@(pk, _, _) = (addressHash pk, signedComm)

-- | Unsafe straightforward constructor of 'CommitmentsMap'.
mkCommitmentsMapUnsafe :: HashMap StakeholderId SignedCommitment
                       -> CommitmentsMap
mkCommitmentsMapUnsafe = CommitmentsMap

----------------------------------------------------------------------------
-- Openings
----------------------------------------------------------------------------

-- | Opening reveals secret.
newtype Opening = Opening
    { getOpening :: AsBinary Secret
    } deriving (Show, Eq, Generic, Buildable, NFData)

instance Bi Opening where
    encode = encode . getOpening
    decode = Opening <$> decode

type OpeningsMap = HashMap StakeholderId Opening

----------------------------------------------------------------------------
-- Shares
----------------------------------------------------------------------------

-- | Each node generates several 'SharedSeed's, breaks every
-- 'SharedSeed' into 'Share's, and sends those encrypted shares to
-- other nodes (for i-th commitment at i-th element of NonEmpty
-- list). Then those shares are decrypted.
type InnerSharesMap = HashMap StakeholderId (NonEmpty (AsBinary DecShare))

-- | In a 'SharesMap', for each node we collect shares which said node
-- has received and decrypted:
--
--   * Outer key = who decrypted the share
--   * Inner key = who created the share
--
-- Let's say that there are participants {A, B, C}. If A has generated a
-- secret and shared it, A's shares will be denoted as Aa, Ab and Ac (sent
-- correspondingly to A itself, B and C). Then node B will decrypt its share
-- and get Ab_dec; same for other nodes and participants. In the end, after
-- the second phase of the protocol completes and we gather everyone's
-- shares, we'll get the following map:
--
-- @
-- { A: {A: Aa_dec, B: Ba_dec, C: Ca_dec}
-- , B: {A: Ab_dec, B: Bb_dec, C: Cb_dec}
-- , C: {A: Ac_dec, B: Bc_dec, C: Cc_dec}
-- }
-- @
--
-- (Here there's only one share per node, but in reality there'll be more.)
type SharesMap = HashMap StakeholderId InnerSharesMap

-- | This maps shareholders to amount of shares she should issue. Depends on
-- the stake distribution.
type SharesDistribution = HashMap StakeholderId Word16

instance Buildable (StakeholderId, Word16) where
    build (id, c) = bprint ("("%build%": "%build%" shares)") id c

----------------------------------------------------------------------------
-- Vss certificates
----------------------------------------------------------------------------

-- | VssCertificate allows VssPublicKey to participate in MPC. Each
-- stakeholder should create a Vss keypair, sign VSS public key with signing
-- key and send it into blockchain.
--
-- A public key of node is included in certificate in order to enable
-- validation of it using only node's P2PKH address. Expiry epoch is last
-- epoch when certificate is valid, expiry epoch is included in certificate
-- and signature.
--
-- Other nodes accept this certificate if it is valid and if node has enough
-- stake.
--
-- Invariant: 'checkSig vcSigningKey (vcVssKey, vcExpiryEpoch) vcSignature'.
data VssCertificate = UnsafeVssCertificate
    { vcVssKey      :: !(AsBinary VssPublicKey)
    , vcExpiryEpoch :: !EpochIndex
    -- ^ Epoch up to which certificate is valid.
    , vcSignature   :: !(Signature (AsBinary VssPublicKey, EpochIndex))
    , vcSigningKey  :: !PublicKey
    } deriving (Show, Eq, Generic)

flip makeLensesFor ''VssCertificate
  [ ("vcVssKey"     , "_vcVssKey")
  , ("vcExpiryEpoch", "_vcExpiryEpoch")
  , ("vcSignature"  , "_vcSignature")
  , ("vcSigningKey" , "_vcSigningKey")
  ]

instance NFData VssCertificate

instance Ord VssCertificate where
    compare a b = toTuple a `compare` toTuple b
      where
        toTuple UnsafeVssCertificate {..} =
            (vcExpiryEpoch, vcVssKey, vcSigningKey, vcSignature)

instance Buildable VssCertificate where
    build UnsafeVssCertificate {..} = bprint
        ("vssCert:"%build%":"%int) vcSigningKey vcExpiryEpoch

instance Hashable VssCertificate where
    hashWithSalt s UnsafeVssCertificate{..} =
        hashWithSalt s (vcExpiryEpoch, vcVssKey, vcSigningKey, vcSignature)

instance Bi VssCertificate where
    encode vssCert = encodeListLen 4 <> encode (vcVssKey vssCert)
                                     <> encode (vcExpiryEpoch vssCert)
                                     <> encode (vcSignature vssCert)
                                     <> encode (vcSigningKey vssCert)
    decode = do
        enforceSize "VssCertificate" 4
        key <- decode
        epo <- decode
        sig <- decode
        sky <- decode
        pure $ UnsafeVssCertificate key epo sig sky

getCertId :: VssCertificate -> StakeholderId
getCertId = addressHash . vcSigningKey

toCertPair :: VssCertificate -> (StakeholderId, VssCertificate)
toCertPair vc = (getCertId vc, vc)

-- | VssCertificatesMap contains all valid certificates collected
-- during some period of time.
--
-- Invariants:
--   * stakeholder ids correspond to 'vcSigningKey's of associated certs
--   * no two certs have the same 'vcVssKey'
newtype VssCertificatesMap = UnsafeVssCertificatesMap
    { getVssCertificatesMap :: HashMap StakeholderId VssCertificate }
    deriving (Eq, Show, Generic, NFData, ToList, Container)

-- | Construct a 'VssCertificatesMap' from a list of certs by making a
-- hashmap on certificate identifiers.
mkVssCertificatesMap :: [VssCertificate] -> VssCertificatesMap
mkVssCertificatesMap = UnsafeVssCertificatesMap . HM.fromList . map toCertPair

-- | A convenient constructor of 'VssCertificatesMap' that throws away
-- certificates with duplicate signing keys or with duplicate 'vcVssKey's.
mkVssCertificatesMapLossy :: [VssCertificate] -> VssCertificatesMap
mkVssCertificatesMapLossy =
    UnsafeVssCertificatesMap . HM.fromList .
    map toCertPair . nubOrdOn vcVssKey

instance Bi VssCertificatesMap where
    encode = encodeVssCertificates
    decode = decodeVssCertificates

{-
'VssCertificatesMap' and 'CommitmentsMap' are simply sets of values, indexed
by stakeholder id *for performance only*; the invariant is that the key
(stakeholder id) corresponds to the key stored in the value. This means that
the keys are redundant and putting them into encoded data is bad for two
reasons:

  * it takes more space
  * we have to do an extra invariant check after decoding

Instead, we serialize those maps as sets, and we make sure to check that
there are no values with duplicate stakeholder ids.
-}

encodeVssCertificates :: VssCertificatesMap -> Encoding
encodeVssCertificates = encode . HS.fromList . toList

decodeVssCertificates :: Decoder s VssCertificatesMap
decodeVssCertificates = do
    certs <- decode @(HashSet VssCertificate)
    let vssMap = mkVssCertificatesMap (toList certs)
    -- If the set is bigger than the map, then there must be some entires in
    -- the set which have the same signing key. That means it's a
    -- non-canonical encoding. The set itself could very well be canonical,
    -- though, since its values include more than just the signing keys.
    when (length certs > length vssMap) (cborError "duplicate vss key")
    pure vssMap


type instance Element VssCertificatesMap = VssCertificate

makeWrapped ''VssCertificatesMap

-- | A left-biased instance
instance Semigroup VssCertificatesMap where
    (UnsafeVssCertificatesMap a) <> (UnsafeVssCertificatesMap b) =
        UnsafeVssCertificatesMap $
        a <> HM.filter (not . (`HS.member` lVssKeys) . vcVssKey) b
      where
        lVssKeys = HS.fromList (map vcVssKey (toList a))

instance Monoid VssCertificatesMap where
    mempty = UnsafeVssCertificatesMap mempty
    mappend = (<>)

----------------------------------------------------------------------------
-- Payload and proof
----------------------------------------------------------------------------

-- | Payload included into blocks.
data SscPayload
    = CommitmentsPayload
        { spComms :: !CommitmentsMap
        , spVss   :: !VssCertificatesMap }
    | OpeningsPayload
        { spOpenings :: !OpeningsMap
        , spVss      :: !VssCertificatesMap }
    | SharesPayload
        { spShares :: !SharesMap
        , spVss    :: !VssCertificatesMap }
    | CertificatesPayload
        { spVss    :: !VssCertificatesMap }
    deriving (Eq, Show, Generic)

-- Note: we can't use 'VssCertificatesMap', because we serialize it as
-- a 'HashSet', but in the very first version of mainnet this map was
-- serialized as a 'HashMap' (and 'VssCertificatesMap' was just a type
-- alias for that 'HashMap').
--
-- Alternative approach would be to keep 'instance Bi VssCertificatesMap'
-- the same as it was in mainnet.
type VssCertificatesHash = Hash (HashMap StakeholderId VssCertificate)

-- | Proof that SSC payload is correct (it's included into block header)
data SscProof
    = CommitmentsProof
        { sprComms :: !(Hash CommitmentsMap)
        , sprVss   :: !VssCertificatesHash }
    | OpeningsProof
        { sprOpenings :: !(Hash OpeningsMap)
        , sprVss      :: !VssCertificatesHash }
    | SharesProof
        { sprShares :: !(Hash SharesMap)
        , sprVss    :: !VssCertificatesHash }
    | CertificatesProof
        { sprVss    :: !VssCertificatesHash }
    deriving (Eq, Show, Generic)

instance Buildable SscProof where
    build = genericF

instance NFData SscPayload
instance NFData SscProof

isEmptySscPayload :: SscPayload -> Bool
isEmptySscPayload (CommitmentsPayload comms certs) = null comms && null certs
isEmptySscPayload (OpeningsPayload opens certs)    = null opens && null certs
isEmptySscPayload (SharesPayload shares certs)     = null shares && null certs
isEmptySscPayload (CertificatesPayload certs)      = null certs

instance Buildable SscPayload where
    build gp
        | isEmptySscPayload gp = "  no SSC payload"
        | otherwise =
            case gp of
                CommitmentsPayload comms certs ->
                    formatTwo formatCommitments comms certs
                OpeningsPayload openings certs ->
                    formatTwo formatOpenings openings certs
                SharesPayload shares certs ->
                    formatTwo formatShares shares certs
                CertificatesPayload certs -> formatCertificates certs
      where
        formatIfNotNull
            :: Container c
            => Format Builder (c -> Builder) -> c -> Builder
        formatIfNotNull formatter l
            | null l = mempty
            | otherwise = bprint formatter l
        formatCommitments (getCommitmentsMap -> comms) =
            formatIfNotNull
                ("  commitments from: " %listJson % "\n")
                (HM.keys comms)
        formatOpenings openings =
            formatIfNotNull
                ("  openings from: " %listJson % "\n")
                (HM.keys openings)
        formatShares shares =
            formatIfNotNull
                ("  shares from: " %listJson % "\n")
                (HM.keys shares)
        formatCertificates (getVssCertificatesMap -> certs) =
            formatIfNotNull
                ("  certificates from: " %listJson % "\n")
                (map formatVssCert $ HM.toList certs)
        formatVssCert (id, cert) =
            bprint (shortHashF%":"%int) id (vcExpiryEpoch cert)
        formatTwo formatter hm certs =
            mconcat [formatter hm, formatCertificates certs]

----------------------------------------------------------------------------
-- TH-generated instances go to the end of the file
----------------------------------------------------------------------------

deriveSimpleBi ''SscPayload [
    Cons 'CommitmentsPayload [
        Field [| spComms    :: CommitmentsMap     |],
        Field [| spVss      :: VssCertificatesMap |] ],
    Cons 'OpeningsPayload [
        Field [| spOpenings :: OpeningsMap        |],
        Field [| spVss      :: VssCertificatesMap |] ],
    Cons 'SharesPayload [
        Field [| spShares   :: SharesMap          |],
        Field [| spVss      :: VssCertificatesMap |] ],
    Cons 'CertificatesPayload [
        Field [| spVss      :: VssCertificatesMap |] ]
    ]

deriveSimpleBi ''SscProof [
    Cons 'CommitmentsProof [
        Field [| sprComms    :: Hash CommitmentsMap |],
        Field [| sprVss      :: VssCertificatesHash |] ],
    Cons 'OpeningsProof [
        Field [| sprOpenings :: Hash OpeningsMap    |],
        Field [| sprVss      :: VssCertificatesHash |] ],
    Cons 'SharesProof [
        Field [| sprShares   :: Hash SharesMap      |],
        Field [| sprVss      :: VssCertificatesHash |] ],
    Cons 'CertificatesProof [
        Field [| sprVss      :: VssCertificatesHash |] ]
    ]
